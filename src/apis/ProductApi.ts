/* tslint:disable */
/* eslint-disable */
/**
 * Geins Management API
 *  Geins Management API is a RESTful api that powers your applications and helps you manage your Geins services. Geins provides an easy-to-use and scalable solution for managing all aspects of an online store, from product listings and customer information to order processing and payment transactions.   :::tip Tip With this API, you can build custom applications and integrate with third-party systems, feeds, dashboards and other bussiness logic apps. :::    ## Getting started Once you have created an account, you can start using the Management API by creating an `API User`. You can create as many API users as you need. Each `API user` is connected to a specific account so you can keep track of operations and manage keys.   You can find all your API credentials in `Geins Merchant Center`.   ### Fast track Use one of our [SDKs](https://docs.geins.io/docs/sdk/introduction) to get started quickly. The SDKs are available for the most popular programming languages and frameworks.  Or, if you prefer to just take it for a test run:  [![Run in Postman](https://run.pstmn.io/button.svg)](https://god.gw.postman.com/run-collection/25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553?action=collection%2Ffork&collection-url=entityId%3D25895885-aaf6598f-1a7c-4949-85d7-ba846c42d553%26entityType%3Dcollection%26workspaceId%3Da2a179ce-158e-46b0-8d06-e9640f45112c)  ### Authentication Two authentication methods are required:   - `Basic Auth`   - `API Key`    All API credentials can be found in `Geins Merchant Center`.  #### Basic Auth A Basic auth `Authorization` header needs to be included in every request. The value should be `Basic <credentials>` where `<credentials>` is the Base64 encoding of your `API username` and `API password` joined by a single colon `:`.   See [Wikipedia](https://en.wikipedia.org/wiki/Basic_access_authentication) for more information on Basic auth.  #### API Key  An `X-ApiKey` header needs to be included in every request. This header should contain the value of your `API key`.  #### Example ```bash curl -X GET \"https://mgmtapi.geins.io/API/Market/List\" \\ -H \"Authorization: Basic [USER-CREDENTIALS-BASE64-ENCODED]\" \\ -H \"X-ApiKey: [API-KEY]\" ``` 
 *
 * The version of the OpenAPI document: v1.10.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BaseEnvelope,
  EnvelopeListProductModelsReadFeed,
  EnvelopeListProductModelsReadProductItem,
  EnvelopeListProductModelsReadProductItemStock,
  EnvelopeListProductModelsReadRelationType,
  EnvelopeProductModelsReadProduct,
  EnvelopeProductModelsReadProductItem,
  EnvelopeProductModelsReadProductItemResult,
  PagedEnvelopeListProductModelsReadProduct,
  ProductModelsMonitorSku,
  ProductModelsProductCategory,
  ProductModelsProductQuery,
  ProductModelsReadProductItem,
  ProductModelsRelatedProductEnvelope,
  ProductModelsStockEnvelope,
  ProductModelsWriteProduct,
  ProductModelsWriteProductItem,
  ProductModelsWriteProductItemStock,
  ProductModelsWriteRelatedProduct,
  ProductProductItemEnvelope,
} from '../models';
import {
    BaseEnvelopeFromJSON,
    BaseEnvelopeToJSON,
    EnvelopeListProductModelsReadFeedFromJSON,
    EnvelopeListProductModelsReadFeedToJSON,
    EnvelopeListProductModelsReadProductItemFromJSON,
    EnvelopeListProductModelsReadProductItemToJSON,
    EnvelopeListProductModelsReadProductItemStockFromJSON,
    EnvelopeListProductModelsReadProductItemStockToJSON,
    EnvelopeListProductModelsReadRelationTypeFromJSON,
    EnvelopeListProductModelsReadRelationTypeToJSON,
    EnvelopeProductModelsReadProductFromJSON,
    EnvelopeProductModelsReadProductToJSON,
    EnvelopeProductModelsReadProductItemFromJSON,
    EnvelopeProductModelsReadProductItemToJSON,
    EnvelopeProductModelsReadProductItemResultFromJSON,
    EnvelopeProductModelsReadProductItemResultToJSON,
    PagedEnvelopeListProductModelsReadProductFromJSON,
    PagedEnvelopeListProductModelsReadProductToJSON,
    ProductModelsMonitorSkuFromJSON,
    ProductModelsMonitorSkuToJSON,
    ProductModelsProductCategoryFromJSON,
    ProductModelsProductCategoryToJSON,
    ProductModelsProductQueryFromJSON,
    ProductModelsProductQueryToJSON,
    ProductModelsReadProductItemFromJSON,
    ProductModelsReadProductItemToJSON,
    ProductModelsRelatedProductEnvelopeFromJSON,
    ProductModelsRelatedProductEnvelopeToJSON,
    ProductModelsStockEnvelopeFromJSON,
    ProductModelsStockEnvelopeToJSON,
    ProductModelsWriteProductFromJSON,
    ProductModelsWriteProductToJSON,
    ProductModelsWriteProductItemFromJSON,
    ProductModelsWriteProductItemToJSON,
    ProductModelsWriteProductItemStockFromJSON,
    ProductModelsWriteProductItemStockToJSON,
    ProductModelsWriteRelatedProductFromJSON,
    ProductModelsWriteRelatedProductToJSON,
    ProductProductItemEnvelopeFromJSON,
    ProductProductItemEnvelopeToJSON,
} from '../models';

export interface AddAvailabilityMonitorRequest {
    model: ProductModelsMonitorSku;
}

export interface AddCategoryToProductRequest {
    productId: string;
    productCategory: ProductModelsProductCategory;
    productIdType?: AddCategoryToProductProductIdTypeEnum;
}

export interface AddRelatedProductsToProductRequest {
    productId: string;
    relatedProducts: Array<ProductModelsWriteRelatedProduct>;
    productIdType?: AddRelatedProductsToProductProductIdTypeEnum;
}

export interface CreateProductRequest {
    product: ProductModelsWriteProduct;
    include?: string;
}

export interface CreateProductItemRequest {
    productId: string;
    productItem: ProductModelsWriteProductItem;
    productIdType?: CreateProductItemProductIdTypeEnum;
}

export interface DeleteProductRequest {
    productId: string;
    productIdType?: DeleteProductProductIdTypeEnum;
}

export interface GetProductRequest {
    productId: string;
    productIdType?: GetProductProductIdTypeEnum;
    include?: string;
}

export interface GetProductItemRequest {
    itemId: string;
    productItemIdType?: GetProductItemProductItemIdTypeEnum;
}

export interface LinkRelatedProductsRequest {
    productId: string;
    relationTypeId: number;
    relatedProducts: Array<ProductModelsWriteRelatedProduct>;
    productIdType?: LinkRelatedProductsProductIdTypeEnum;
}

export interface ListProductItemsPagedRequest {
    page: number;
}

export interface QueryProductsRequest {
    query: ProductModelsProductQuery;
    include?: string;
}

export interface QueryProductsPagedRequest {
    page: number;
    query: ProductModelsProductQuery;
    include?: string;
}

export interface QueryStockRequest {
    productItemIds: Array<number>;
}

export interface UnlinkRelatedProductsViaRelationRequest {
    productId: string;
    relationTypeId: number;
    relatedProducts: Array<ProductModelsWriteRelatedProduct>;
    productIdType?: UnlinkRelatedProductsViaRelationProductIdTypeEnum;
}

export interface UpdateProductRequest {
    productId: string;
    product: ProductModelsWriteProduct;
    productIdType?: UpdateProductProductIdTypeEnum;
    include?: string;
}

export interface UpdateProductItemRequest {
    itemId: string;
    productItem: ProductModelsWriteProductItem;
    productItemIdType?: UpdateProductItemProductItemIdTypeEnum;
}

export interface UpdateProductItemsBatchRequest {
    productItems: Array<ProductModelsWriteProductItem>;
    productItemIdType?: UpdateProductItemsBatchProductItemIdTypeEnum;
}

export interface UpdateStockBatchRequest {
    productItemStocks: Array<ProductModelsWriteProductItemStock>;
    productItemIdType?: UpdateStockBatchProductItemIdTypeEnum;
}

/**
 * 
 */
export class ProductApi extends runtime.BaseAPI {

    /**
     * Adds a product availability monitor.
     * Add availability monitor
     */
    async addAvailabilityMonitorRaw(requestParameters: AddAvailabilityMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseEnvelope>> {
        if (requestParameters.model === null || requestParameters.model === undefined) {
            throw new runtime.RequiredError('model','Required parameter requestParameters.model was null or undefined when calling addAvailabilityMonitor.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/MonitorAvailability`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsMonitorSkuToJSON(requestParameters.model),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseEnvelopeFromJSON(jsonValue));
    }

    /**
     * Adds a product availability monitor.
     * Add availability monitor
     */
    async addAvailabilityMonitor(requestParameters: AddAvailabilityMonitorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseEnvelope> {
        const response = await this.addAvailabilityMonitorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a category relation to a product.
     * Add category to product
     */
    async addCategoryToProductRaw(requestParameters: AddCategoryToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseEnvelope>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling addCategoryToProduct.');
        }

        if (requestParameters.productCategory === null || requestParameters.productCategory === undefined) {
            throw new runtime.RequiredError('productCategory','Required parameter requestParameters.productCategory was null or undefined when calling addCategoryToProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/Category`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsProductCategoryToJSON(requestParameters.productCategory),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseEnvelopeFromJSON(jsonValue));
    }

    /**
     * Adds a category relation to a product.
     * Add category to product
     */
    async addCategoryToProduct(requestParameters: AddCategoryToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseEnvelope> {
        const response = await this.addCategoryToProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add related products to a product
     */
    async addRelatedProductsToProductRaw(requestParameters: AddRelatedProductsToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductModelsRelatedProductEnvelope>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling addRelatedProductsToProduct.');
        }

        if (requestParameters.relatedProducts === null || requestParameters.relatedProducts === undefined) {
            throw new runtime.RequiredError('relatedProducts','Required parameter requestParameters.relatedProducts was null or undefined when calling addRelatedProductsToProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/Related`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.relatedProducts.map(ProductModelsWriteRelatedProductToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductModelsRelatedProductEnvelopeFromJSON(jsonValue));
    }

    /**
     * Add related products to a product
     */
    async addRelatedProductsToProduct(requestParameters: AddRelatedProductsToProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductModelsRelatedProductEnvelope> {
        const response = await this.addRelatedProductsToProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new product.
     * Create product
     */
    async createProductRaw(requestParameters: CreateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProduct>> {
        if (requestParameters.product === null || requestParameters.product === undefined) {
            throw new runtime.RequiredError('product','Required parameter requestParameters.product was null or undefined when calling createProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsWriteProductToJSON(requestParameters.product),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * Creates a new product.
     * Create product
     */
    async createProduct(requestParameters: CreateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProduct> {
        const response = await this.createProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new product item.
     * Create product item
     */
    async createProductItemRaw(requestParameters: CreateProductItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProductItem>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling createProductItem.');
        }

        if (requestParameters.productItem === null || requestParameters.productItem === undefined) {
            throw new runtime.RequiredError('productItem','Required parameter requestParameters.productItem was null or undefined when calling createProductItem.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/Item`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsWriteProductItemToJSON(requestParameters.productItem),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductItemFromJSON(jsonValue));
    }

    /**
     * Creates a new product item.
     * Create product item
     */
    async createProductItem(requestParameters: CreateProductItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProductItem> {
        const response = await this.createProductItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a specific product.
     * Delete product
     */
    async deleteProductRaw(requestParameters: DeleteProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseEnvelope>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling deleteProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseEnvelopeFromJSON(jsonValue));
    }

    /**
     * Deletes a specific product.
     * Delete product
     */
    async deleteProduct(requestParameters: DeleteProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseEnvelope> {
        const response = await this.deleteProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a specific product. Make sure to include relevant child-collections in the request.
     * Get product
     */
    async getProductRaw(requestParameters: GetProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProduct>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling getProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * Gets a specific product. Make sure to include relevant child-collections in the request.
     * Get product
     */
    async getProduct(requestParameters: GetProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProduct> {
        const response = await this.getProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a specific product item (SKU).
     * Get product item
     */
    async getProductItemRaw(requestParameters: GetProductItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductProductItemEnvelope>> {
        if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
            throw new runtime.RequiredError('itemId','Required parameter requestParameters.itemId was null or undefined when calling getProductItem.');
        }

        const queryParameters: any = {};

        if (requestParameters.productItemIdType !== undefined) {
            queryParameters['productItemIdType'] = requestParameters.productItemIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Item/{itemId}`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductProductItemEnvelopeFromJSON(jsonValue));
    }

    /**
     * Gets a specific product item (SKU).
     * Get product item
     */
    async getProductItem(requestParameters: GetProductItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductProductItemEnvelope> {
        const response = await this.getProductItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add related products to a product using a fixed relation type.
     * Link related products
     */
    async linkRelatedProductsRaw(requestParameters: LinkRelatedProductsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductModelsRelatedProductEnvelope>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling linkRelatedProducts.');
        }

        if (requestParameters.relationTypeId === null || requestParameters.relationTypeId === undefined) {
            throw new runtime.RequiredError('relationTypeId','Required parameter requestParameters.relationTypeId was null or undefined when calling linkRelatedProducts.');
        }

        if (requestParameters.relatedProducts === null || requestParameters.relatedProducts === undefined) {
            throw new runtime.RequiredError('relatedProducts','Required parameter requestParameters.relatedProducts was null or undefined when calling linkRelatedProducts.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/Related/{relationTypeId}`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))).replace(`{${"relationTypeId"}}`, encodeURIComponent(String(requestParameters.relationTypeId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.relatedProducts.map(ProductModelsWriteRelatedProductToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductModelsRelatedProductEnvelopeFromJSON(jsonValue));
    }

    /**
     * Add related products to a product using a fixed relation type.
     * Link related products
     */
    async linkRelatedProducts(requestParameters: LinkRelatedProductsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductModelsRelatedProductEnvelope> {
        const response = await this.linkRelatedProductsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a list of all feeds.
     * List feeds
     */
    async listFeedsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeListProductModelsReadFeed>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Feeds`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeListProductModelsReadFeedFromJSON(jsonValue));
    }

    /**
     * Gets a list of all feeds.
     * List feeds
     */
    async listFeeds(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeListProductModelsReadFeed> {
        const response = await this.listFeedsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets all product items.
     * List product items
     */
    async listProductItemsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProductModelsReadProductItem>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Items`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProductModelsReadProductItemFromJSON));
    }

    /**
     * Gets all product items.
     * List product items
     */
    async listProductItems(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProductModelsReadProductItem>> {
        const response = await this.listProductItemsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets all product items with pagination.
     * List product items (paged)
     */
    async listProductItemsPagedRaw(requestParameters: ListProductItemsPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeListProductModelsReadProductItem>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling listProductItemsPaged.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Items/{page}`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeListProductModelsReadProductItemFromJSON(jsonValue));
    }

    /**
     * Gets all product items with pagination.
     * List product items (paged)
     */
    async listProductItemsPaged(requestParameters: ListProductItemsPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeListProductModelsReadProductItem> {
        const response = await this.listProductItemsPagedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a list of product relation types
     * List product relation types
     */
    async listProductRelationTypesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeListProductModelsReadRelationType>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/RelationTypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeListProductModelsReadRelationTypeFromJSON(jsonValue));
    }

    /**
     * Gets a list of product relation types
     * List product relation types
     */
    async listProductRelationTypes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeListProductModelsReadRelationType> {
        const response = await this.listProductRelationTypesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Query products
     */
    async queryProductsRaw(requestParameters: QueryProductsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PagedEnvelopeListProductModelsReadProduct>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling queryProducts.');
        }

        const queryParameters: any = {};

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Query`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsProductQueryToJSON(requestParameters.query),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PagedEnvelopeListProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * Query products
     */
    async queryProducts(requestParameters: QueryProductsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PagedEnvelopeListProductModelsReadProduct> {
        const response = await this.queryProductsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The batch id is mandatory when fetching any page other than the first page.    If no batch id is provided for the first page, then a new batch is created.    Batch id and pagination information can be found in the response.
     * Query products (paged)
     */
    async queryProductsPagedRaw(requestParameters: QueryProductsPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PagedEnvelopeListProductModelsReadProduct>> {
        if (requestParameters.page === null || requestParameters.page === undefined) {
            throw new runtime.RequiredError('page','Required parameter requestParameters.page was null or undefined when calling queryProductsPaged.');
        }

        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling queryProductsPaged.');
        }

        const queryParameters: any = {};

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Query/{page}`.replace(`{${"page"}}`, encodeURIComponent(String(requestParameters.page))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsProductQueryToJSON(requestParameters.query),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PagedEnvelopeListProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * The batch id is mandatory when fetching any page other than the first page.    If no batch id is provided for the first page, then a new batch is created.    Batch id and pagination information can be found in the response.
     * Query products (paged)
     */
    async queryProductsPaged(requestParameters: QueryProductsPagedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PagedEnvelopeListProductModelsReadProduct> {
        const response = await this.queryProductsPagedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query stock
     */
    async queryStockRaw(requestParameters: QueryStockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeListProductModelsReadProductItemStock>> {
        if (requestParameters.productItemIds === null || requestParameters.productItemIds === undefined) {
            throw new runtime.RequiredError('productItemIds','Required parameter requestParameters.productItemIds was null or undefined when calling queryStock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Stock/Query`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.productItemIds,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeListProductModelsReadProductItemStockFromJSON(jsonValue));
    }

    /**
     * Query stock
     */
    async queryStock(requestParameters: QueryStockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeListProductModelsReadProductItemStock> {
        const response = await this.queryStockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove related products from a product using a fixed relation type.
     * Unlink related products (via relation).
     */
    async unlinkRelatedProductsViaRelationRaw(requestParameters: UnlinkRelatedProductsViaRelationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductModelsRelatedProductEnvelope>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling unlinkRelatedProductsViaRelation.');
        }

        if (requestParameters.relationTypeId === null || requestParameters.relationTypeId === undefined) {
            throw new runtime.RequiredError('relationTypeId','Required parameter requestParameters.relationTypeId was null or undefined when calling unlinkRelatedProductsViaRelation.');
        }

        if (requestParameters.relatedProducts === null || requestParameters.relatedProducts === undefined) {
            throw new runtime.RequiredError('relatedProducts','Required parameter requestParameters.relatedProducts was null or undefined when calling unlinkRelatedProductsViaRelation.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}/UnlinkRelated/{relationTypeId}`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))).replace(`{${"relationTypeId"}}`, encodeURIComponent(String(requestParameters.relationTypeId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.relatedProducts.map(ProductModelsWriteRelatedProductToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductModelsRelatedProductEnvelopeFromJSON(jsonValue));
    }

    /**
     * Remove related products from a product using a fixed relation type.
     * Unlink related products (via relation).
     */
    async unlinkRelatedProductsViaRelation(requestParameters: UnlinkRelatedProductsViaRelationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductModelsRelatedProductEnvelope> {
        const response = await this.unlinkRelatedProductsViaRelationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a product.
     * Update product
     */
    async updateProductRaw(requestParameters: UpdateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProduct>> {
        if (requestParameters.productId === null || requestParameters.productId === undefined) {
            throw new runtime.RequiredError('productId','Required parameter requestParameters.productId was null or undefined when calling updateProduct.');
        }

        if (requestParameters.product === null || requestParameters.product === undefined) {
            throw new runtime.RequiredError('product','Required parameter requestParameters.product was null or undefined when calling updateProduct.');
        }

        const queryParameters: any = {};

        if (requestParameters.productIdType !== undefined) {
            queryParameters['productIdType'] = requestParameters.productIdType;
        }

        if (requestParameters.include !== undefined) {
            queryParameters['include'] = requestParameters.include;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/{productId}`.replace(`{${"productId"}}`, encodeURIComponent(String(requestParameters.productId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsWriteProductToJSON(requestParameters.product),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductFromJSON(jsonValue));
    }

    /**
     * Updates a product.
     * Update product
     */
    async updateProduct(requestParameters: UpdateProductRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProduct> {
        const response = await this.updateProductRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a product item.
     * Update product item
     */
    async updateProductItemRaw(requestParameters: UpdateProductItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProductItem>> {
        if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
            throw new runtime.RequiredError('itemId','Required parameter requestParameters.itemId was null or undefined when calling updateProductItem.');
        }

        if (requestParameters.productItem === null || requestParameters.productItem === undefined) {
            throw new runtime.RequiredError('productItem','Required parameter requestParameters.productItem was null or undefined when calling updateProductItem.');
        }

        const queryParameters: any = {};

        if (requestParameters.productItemIdType !== undefined) {
            queryParameters['productItemIdType'] = requestParameters.productItemIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Item/{itemId}`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProductModelsWriteProductItemToJSON(requestParameters.productItem),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductItemFromJSON(jsonValue));
    }

    /**
     * Updates a product item.
     * Update product item
     */
    async updateProductItem(requestParameters: UpdateProductItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProductItem> {
        const response = await this.updateProductItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates product items in batch.
     * Update product items (batch)
     */
    async updateProductItemsBatchRaw(requestParameters: UpdateProductItemsBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvelopeProductModelsReadProductItemResult>> {
        if (requestParameters.productItems === null || requestParameters.productItems === undefined) {
            throw new runtime.RequiredError('productItems','Required parameter requestParameters.productItems was null or undefined when calling updateProductItemsBatch.');
        }

        const queryParameters: any = {};

        if (requestParameters.productItemIdType !== undefined) {
            queryParameters['productItemIdType'] = requestParameters.productItemIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Items`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.productItems.map(ProductModelsWriteProductItemToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvelopeProductModelsReadProductItemResultFromJSON(jsonValue));
    }

    /**
     * Updates product items in batch.
     * Update product items (batch)
     */
    async updateProductItemsBatch(requestParameters: UpdateProductItemsBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvelopeProductModelsReadProductItemResult> {
        const response = await this.updateProductItemsBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update stock values for multiple product items.
     * Update stock (batch)
     */
    async updateStockBatchRaw(requestParameters: UpdateStockBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProductModelsStockEnvelope>> {
        if (requestParameters.productItemStocks === null || requestParameters.productItemStocks === undefined) {
            throw new runtime.RequiredError('productItemStocks','Required parameter requestParameters.productItemStocks was null or undefined when calling updateStockBatch.');
        }

        const queryParameters: any = {};

        if (requestParameters.productItemIdType !== undefined) {
            queryParameters['productItemIdType'] = requestParameters.productItemIdType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-ApiKey"] = this.configuration.apiKey("X-ApiKey"); // apiKey authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/API/Product/Stock`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.productItemStocks.map(ProductModelsWriteProductItemStockToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProductModelsStockEnvelopeFromJSON(jsonValue));
    }

    /**
     * Update stock values for multiple product items.
     * Update stock (batch)
     */
    async updateStockBatch(requestParameters: UpdateStockBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProductModelsStockEnvelope> {
        const response = await this.updateStockBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const AddCategoryToProductProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type AddCategoryToProductProductIdTypeEnum = typeof AddCategoryToProductProductIdTypeEnum[keyof typeof AddCategoryToProductProductIdTypeEnum];
/**
 * @export
 */
export const AddRelatedProductsToProductProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type AddRelatedProductsToProductProductIdTypeEnum = typeof AddRelatedProductsToProductProductIdTypeEnum[keyof typeof AddRelatedProductsToProductProductIdTypeEnum];
/**
 * @export
 */
export const CreateProductItemProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type CreateProductItemProductIdTypeEnum = typeof CreateProductItemProductIdTypeEnum[keyof typeof CreateProductItemProductIdTypeEnum];
/**
 * @export
 */
export const DeleteProductProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type DeleteProductProductIdTypeEnum = typeof DeleteProductProductIdTypeEnum[keyof typeof DeleteProductProductIdTypeEnum];
/**
 * @export
 */
export const GetProductProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type GetProductProductIdTypeEnum = typeof GetProductProductIdTypeEnum[keyof typeof GetProductProductIdTypeEnum];
/**
 * @export
 */
export const GetProductItemProductItemIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;
export type GetProductItemProductItemIdTypeEnum = typeof GetProductItemProductItemIdTypeEnum[keyof typeof GetProductItemProductItemIdTypeEnum];
/**
 * @export
 */
export const LinkRelatedProductsProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type LinkRelatedProductsProductIdTypeEnum = typeof LinkRelatedProductsProductIdTypeEnum[keyof typeof LinkRelatedProductsProductIdTypeEnum];
/**
 * @export
 */
export const UnlinkRelatedProductsViaRelationProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type UnlinkRelatedProductsViaRelationProductIdTypeEnum = typeof UnlinkRelatedProductsViaRelationProductIdTypeEnum[keyof typeof UnlinkRelatedProductsViaRelationProductIdTypeEnum];
/**
 * @export
 */
export const UpdateProductProductIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type UpdateProductProductIdTypeEnum = typeof UpdateProductProductIdTypeEnum[keyof typeof UpdateProductProductIdTypeEnum];
/**
 * @export
 */
export const UpdateProductItemProductItemIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;
export type UpdateProductItemProductItemIdTypeEnum = typeof UpdateProductItemProductItemIdTypeEnum[keyof typeof UpdateProductItemProductItemIdTypeEnum];
/**
 * @export
 */
export const UpdateProductItemsBatchProductItemIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;
export type UpdateProductItemsBatchProductItemIdTypeEnum = typeof UpdateProductItemsBatchProductItemIdTypeEnum[keyof typeof UpdateProductItemsBatchProductItemIdTypeEnum];
/**
 * @export
 */
export const UpdateStockBatchProductItemIdTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;
export type UpdateStockBatchProductItemIdTypeEnum = typeof UpdateStockBatchProductItemIdTypeEnum[keyof typeof UpdateStockBatchProductItemIdTypeEnum];
